____
# Урок 1. Обобщения
##### 1. Написать метод, который меняет два элемента массива местами (массив может быть любого ссылочного типа);
##### 2. Написать метод, который преобразует массив в ArrayList;
##### 3. Задача:
##### Даны классы Fruit, Apple extends Fruit, Orange extends Fruit;
##### Класс Box, в который можно складывать фрукты. Коробки условно сортируются по типу фрукта, поэтому в одну коробку нельзя сложить и яблоки, и апельсины;
##### Для хранения фруктов внутри коробки можно использовать ArrayList;
##### Сделать метод getWeight(), который высчитывает вес коробки, зная вес одного фрукта и их количество: вес яблока – 1.0f, апельсина – 1.5f (единицы измерения не важны);
##### Внутри класса Box сделать метод compare(), который позволяет сравнить текущую коробку с той, которую подадут в compare() в качестве параметра. true – если их массы равны, false в противоположном случае. Можно сравнивать коробки с яблоками и апельсинами;
##### Написать метод, который позволяет пересыпать фрукты из текущей коробки в другую. Помним про сортировку фруктов: нельзя яблоки высыпать в коробку с апельсинами. Соответственно, в текущей коробке фруктов не остается, а в другую перекидываются объекты, которые были в первой;
##### Не забываем про метод добавления фрукта в коробку.
____
# Урок 2. Базы данных
##### 1. Добавить в сетевой чат аутентификацию через базу данных SQLite.
##### 2. * Добавить в сетевой чат возможность смены ника.
____
# Урок 3. Средства ввода-вывода
##### 1. Добавить в сетевой чат запись локальной истории в текстовый файл на клиенте. Для каждой учетной записи файл с историей должен называться history_[login].txt. (Например, history_login1.txt, history_user111.txt)
##### 2. ** После загрузки клиента показывать ему последние 100 строк истории чата.
____
# Урок 4. Многопоточность. Часть I
##### 1. Создать три потока, каждый из которых выводит определенную букву (A, B и C) 5 раз (порядок – ABСABСABС). Используйте wait/notify/notifyAll.
____
# Урок 5. Многопоточность. Часть II
##### 1. Перенести приведенный ниже код в новый проект, где мы организуем гонки. 
##### Все участники должны стартовать одновременно, несмотря на разное время  подготовки. В тоннель не может одновременно заехать больше половины участников (условность).
##### Попробуйте все это синхронизировать.
##### Первый участник, пересекший финишную черту, объявляется победителем (в момент пересечения этой самой черты). Победитель должен быть только один (ситуация с 0 или 2+ победителями недопустима).
##### Когда все завершат гонку, нужно выдать объявление об окончании.
##### Можно корректировать классы (в том числе конструктор машин) и добавлять объекты классов из пакета java.util.concurrent.
____
# Урок 6. Обзор средств разработки
##### 1. Написать метод, которому в качестве аргумента передается не пустой одномерный целочисленный массив. Метод должен вернуть новый массив, который получен путем вытаскивания из исходного массива элементов, идущих после последней четверки. Входной массив должен содержать хотя бы одну четверку, иначе в методе необходимо выбросить RuntimeException.
##### Написать набор тестов для этого метода (по 3-4 варианта входных данных).
##### Вх: [ 1 2 4 4 2 3 4 1 7 ] -> вых: [ 1 7 ].
##### 2. Написать метод, который проверяет состав массива из чисел 1 и 4. Если в нем нет хоть одной четверки или единицы, то метод вернет false; Написать набор тестов для этого метода (по 3-4 варианта входных данных).
##### [ 1 1 1 4 4 1 4 4 ] -> true
##### [ 1 1 1 1 1 1 ] -> false
##### [ 4 4 4 4 ] -> false
##### [ 1 4 4 1 1 4 3 ] -> false
____
# Урок 7. Reflection API и аннотации
##### 1. Создать класс, который может выполнять «тесты». 
##### В качестве тестов выступают классы с наборами методов, снабженных аннотациями @Test. Класс, запускающий тесты, должен иметь статический метод start(Class testClass), которому в качестве аргумента передается объект типа Class. Из «класса-теста» вначале должен быть запущен метод с аннотацией @BeforeSuite, если он присутствует. Далее запускаются методы с аннотациями @Test, а по завершении всех тестов – метод с аннотацией @AfterSuite. 
##### К каждому тесту необходимо добавить приоритеты (int-числа от 1 до 10), в соответствии с которыми будет выбираться порядок их выполнения. Если приоритет одинаковый, то порядок не имеет значения. Методы с аннотациями @BeforeSuite и @AfterSuite должны присутствовать в единственном экземпляре. Если это не так – необходимо бросить RuntimeException при запуске «тестирования». 
##### P.S. Это практическое задание – проект, который пишется «с нуля». Данная задача не связана напрямую с темой тестирования через JUnit
____
